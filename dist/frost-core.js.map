{"version":3,"file":"frost-core.js","sources":["../src/testing.js","../src/math.js","../src/array.js","../src/function.js","../src/object.js","../src/string.js"],"sourcesContent":["/**\n * Testing methods\n */\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\nconst DOCUMENT_NODE = 9;\nconst DOCUMENT_FRAGMENT_NODE = 11;\n\n/**\n * Returns true if the value is an array.\n * @param {*} value The value to test.\n * @returns {Boolean} TRUE if the value is an array, otherwise FALSE.\n */\nexport const isArray = Array.isArray;\n\n/**\n * Returns true if the value is array-like.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is array-like, otherwise FALSE.\n */\nexport const isArrayLike = (value) =>\n    isArray(value) ||\n    (\n        isObject(value) &&\n        !isFunction(value) &&\n        !isWindow(value) &&\n        !isElement(value) &&\n        (\n            (\n                Symbol.iterator in value &&\n                isFunction(value[Symbol.iterator])\n            ) ||\n            (\n                'length' in value &&\n                isNumeric(value.length) &&\n                (\n                    !value.length ||\n                    value.length - 1 in value\n                )\n            )\n        )\n    );\n\n/**\n * Returns true if the value is a Boolean.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is boolean, otherwise FALSE.\n */\nexport const isBoolean = (value) =>\n    value === !!value;\n\n/**\n * Returns true if the value is a Document.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is a Document, otherwise FALSE.\n */\nexport const isDocument = (value) =>\n    !!value &&\n    value.nodeType === DOCUMENT_NODE;\n\n/**\n * Returns true if the value is a HTMLElement.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is a HTMLElement, otherwise FALSE.\n */\nexport const isElement = (value) =>\n    !!value &&\n    value.nodeType === ELEMENT_NODE;\n\n/**\n * Returns true if the value is a DocumentFragment.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is a DocumentFragment, otherwise FALSE.\n */\nexport const isFragment = (value) =>\n    !!value &&\n    value.nodeType === DOCUMENT_FRAGMENT_NODE &&\n    !value.host;\n\n/**\n * Returns true if the value is a function.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is a function, otherwise FALSE.\n */\nexport const isFunction = (value) =>\n    typeof value === 'function';\n\n/**\n * Returns true if the value is NaN.\n * @param {*} value The value to test.\n * @returns {Boolean} TRUE if the value is NaN, otherwise FALSE.\n */\nexport const isNaN = Number.isNaN;\n\n/**\n * Returns true if the value is a Node.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is a Node, otherwise FALSE.\n */\nexport const isNode = (value) =>\n    !!value &&\n    (\n        value.nodeType === ELEMENT_NODE ||\n        value.nodeType === TEXT_NODE ||\n        value.nodeType === COMMENT_NODE\n    );\n\n/**\n * Returns true if the value is null.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is null, otherwise FALSE.\n */\nexport const isNull = (value) =>\n    value === null;\n\n/**\n * Returns true if the value is numeric.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is numeric, otherwise FALSE.\n */\nexport const isNumeric = (value) =>\n    !isNaN(parseFloat(value)) &&\n    isFinite(value);\n\n/**\n * Returns true if the value is an object.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is an object, otherwise FALSE.\n */\nexport const isObject = (value) =>\n    !!value &&\n    value === Object(value);\n\n/**\n * Returns true if the value is a plain object.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is a plain object, otherwise FALSE.\n */\nexport const isPlainObject = (value) =>\n    !!value &&\n    value.constructor === Object;\n\n/**\n * Returns true if the value is a ShadowRoot.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is a ShadowRoot, otherwise FALSE.\n */\nexport const isShadow = (value) =>\n    !!value &&\n    value.nodeType === DOCUMENT_FRAGMENT_NODE &&\n    !!value.host;\n\n/**\n * Returns true if the value is a string.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE is the value is a string, otherwise FALSE.\n */\nexport const isString = (value) =>\n    value === `${value}`;\n\n/**\n * Returns true if the value is a text Node.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is a text Node, otherwise FALSE.\n */\nexport const isText = (value) =>\n    !!value &&\n    value.nodeType === TEXT_NODE;\n\n/**\n * Returns true if the value is undefined.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is undefined, otherwise FALSE.\n */\nexport const isUndefined = (value) =>\n    value === undefined;\n\n/**\n * Returns true if the value is a Window.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE is the value is a Window, otherwise FALSE.\n */\nexport const isWindow = (value) =>\n    !!value &&\n    !!value.document &&\n    value.document.defaultView === value;\n","import { isNull } from './testing.js';\n\n/**\n * Math methods\n */\n\n/**\n * Clamp a value between a min and max.\n * @param {number} value The value to clamp.\n * @param {number} [min=0] The minimum value of the clamped range.\n * @param {number} [max=1] The maximum value of the clamped range.\n * @return {number} The clamped value.\n */\nexport const clamp = (value, min = 0, max = 1) =>\n    Math.max(\n        min,\n        Math.min(\n            max,\n            value,\n        ),\n    );\n\n/**\n * Clamp a value between 0 and 100.\n * @param {number} value The value to clamp.\n * @return {number} The clamped value.\n */\nexport const clampPercent = (value) =>\n    clamp(value, 0, 100);\n\n/**\n * Get the distance between two vectors.\n * @param {number} x1 The first vector X co-ordinate.\n * @param {number} y1 The first vector Y co-ordinate.\n * @param {number} x2 The second vector X co-ordinate.\n * @param {number} y2 The second vector Y co-ordinate.\n * @return {number} The distance between the vectors.\n */\nexport const dist = (x1, y1, x2, y2) =>\n    len(\n        x1 - x2,\n        y1 - y2,\n    );\n\n/**\n * Inverse linear interpolation from one value to another.\n * @param {number} v1 The starting value.\n * @param {number} v2 The ending value.\n * @param {number} value The value to inverse interpolate.\n * @return {number} The interpolated amount.\n */\nexport const inverseLerp = (v1, v2, value) =>\n    (value - v1) / (v2 - v1);\n\n/**\n * Get the length of an X,Y vector.\n * @param {number} x The X co-ordinate.\n * @param {number} y The Y co-ordinate.\n * @returns {number} The length of the vector.\n */\nexport const len = Math.hypot;\n\n/**\n * Linear interpolation from one value to another.\n * @param {number} v1 The starting value.\n * @param {number} v2 The ending value.\n * @param {number} amount The amount to interpolate.\n * @return {number} The interpolated value.\n */\nexport const lerp = (v1, v2, amount) =>\n    v1 *\n    (1 - amount) +\n    v2 *\n    amount;\n\n/**\n * Map a value from one range to another.\n * @param {number} value The value to map.\n * @param {number} fromMin The minimum value of the current range.\n * @param {number} fromMax The maximum value of the current range.\n * @param {number} toMin The minimum value of the target range.\n * @param {number} toMax The maximum value of the target range.\n * @return {number} The mapped value.\n */\nexport const map = (value, fromMin, fromMax, toMin, toMax) =>\n    (value - fromMin) *\n    (toMax - toMin) /\n    (fromMax - fromMin) +\n    toMin;\n\n/**\n * Return a random floating-point number.\n * @param {number} [a=1] The minimum value (inclusive).\n * @param {number} [b] The maximum value (exclusive).\n * @return {number} A random number.\n */\nexport const random = (a = 1, b = null) =>\n    isNull(b) ?\n        Math.random() * a :\n        map(\n            Math.random(),\n            0,\n            1,\n            a,\n            b,\n        );\n\n/**\n * Return a random number.\n * @param {number} [a=1] The minimum value (inclusive).\n * @param {number} [b] The maximum value (exclusive).\n * @return {number} A random number.\n */\nexport const randomInt = (a = 1, b = null) =>\n    random(a, b) | 0;\n\n/**\n * Constrain a number to a specified step-size.\n * @param {number} value The value to constrain.\n * @param {number} step The minimum step-size.\n * @return {number} The constrained value.\n */\nexport const toStep = (value, step = 0.01) =>\n    parseFloat(\n        (\n            Math.round(value / step) *\n            step\n        ).toFixed(\n            `${step}`.replace(/\\d*\\.?/, '').length,\n        ),\n    );\n","import { randomInt, toStep } from './math.js';\nimport { isArray, isArrayLike, isUndefined } from './testing.js';\n\n/**\n * Array methods\n */\n\n/**\n * Create a new array containing the values of the first array, that do not exist in any of the additional passed arrays.\n * @param {array} array The input array.\n * @param {...array} arrays The arrays to compare against.\n * @return {array} The output array.\n */\nexport const diff = (array, ...arrays) => {\n    arrays = arrays.map(unique);\n    return array.filter(\n        (value) => !arrays\n            .some((other) => other.includes(value)),\n    );\n};\n\n/**\n * Create a new array containing the unique values that exist in all of the passed arrays.\n * @param {...array} arrays The input arrays.\n * @return {array} The output array.\n */\nexport const intersect = (...arrays) =>\n    unique(\n        arrays\n            .reduce(\n                (acc, array, index) => {\n                    array = unique(array);\n                    return merge(\n                        acc,\n                        array.filter(\n                            (value) =>\n                                arrays.every(\n                                    (other, otherIndex) =>\n                                        index == otherIndex ||\n                                        other.includes(value),\n                                ),\n                        ),\n                    );\n                },\n                [],\n            ),\n    );\n\n/**\n * Merge the values from one or more arrays or array-like objects onto an array.\n * @param {array} array The input array.\n * @param {...array|object} arrays The arrays or array-like objects to merge.\n * @return {array} The output array.\n */\nexport const merge = (array = [], ...arrays) =>\n    arrays.reduce(\n        (acc, other) => {\n            Array.prototype.push.apply(acc, other);\n            return array;\n        },\n        array,\n    );\n\n/**\n * Return a random value from an array.\n * @param {array} array The input array.\n * @return {*} A random value from the array, or null if it is empty.\n */\nexport const randomValue = (array) =>\n    array.length ?\n        array[randomInt(array.length)] :\n        null;\n\n/**\n * Return an array containing a range of values.\n * @param {number} start The first value of the sequence.\n * @param {number} end The value to end the sequence on.\n * @param {number} [step=1] The increment between values in the sequence.\n * @return {number[]} The array of values from start to end.\n */\nexport const range = (start, end, step = 1) => {\n    const sign = Math.sign(end - start);\n    return new Array(\n        (\n            (\n                Math.abs(end - start) /\n                step\n            ) +\n            1\n        ) | 0,\n    )\n        .fill()\n        .map(\n            (_, i) =>\n                start + toStep(\n                    (i * step * sign),\n                    step,\n                ),\n        );\n};\n\n/**\n * Remove duplicate elements in an array.\n * @param {array} array The input array.\n * @return {array} The filtered array.\n */\nexport const unique = (array) =>\n    Array.from(\n        new Set(array),\n    );\n\n/**\n * Create an array from any value.\n * @param {*} value The input value.\n * @return {array} The wrapped array.\n */\nexport const wrap = (value) =>\n    isUndefined(value) ?\n        [] :\n        (\n            isArray(value) ?\n                value :\n                (\n                    isArrayLike(value) ?\n                        merge([], value) :\n                        [value]\n                )\n        );\n","import { isFunction, isUndefined } from './testing.js';\n\n/**\n * Function methods\n */\n\nconst isBrowser = typeof window !== 'undefined' && 'requestAnimationFrame' in window;\n\n/**\n * Execute a callback on the next animation frame\n * @param {function} callback Callback function to execute.\n * @return {number} The request ID.\n */\nconst _requestAnimationFrame = isBrowser ?\n    (...args) => window.requestAnimationFrame(...args) :\n    (callback) => setTimeout(callback, 1000 / 60);\n\n/**\n * Create a wrapped version of a function that executes at most once per animation frame\n * (using the most recent arguments passed to it).\n * @param {function} callback Callback function to execute.\n * @param {Boolean} [leading] Whether to execute on the leading edge of the animation frame.\n * @return {function} The wrapped function.\n */\nexport const animation = (callback, leading) => {\n    let animationReference;\n    let newArgs;\n    let running;\n\n    const animation = (...args) => {\n        newArgs = args;\n\n        if (running) {\n            return;\n        }\n\n        if (leading) {\n            callback(...newArgs);\n        }\n\n        running = true;\n        animationReference = _requestAnimationFrame((_) => {\n            if (!leading) {\n                callback(...newArgs);\n            }\n\n            running = false;\n            animationReference = null;\n        });\n    };\n\n    animation.cancel = (_) => {\n        if (!animationReference) {\n            return;\n        }\n\n        if (isBrowser) {\n            global.cancelAnimationFrame(animationReference);\n        } else {\n            clearTimeout(animationReference);\n        }\n\n        running = false;\n        animationReference = null;\n    };\n\n    return animation;\n};\n\n/**\n * Create a wrapped function that will execute each callback in reverse order,\n * passing the result from each function to the previous.\n * @param {...function} callbacks Callback functions to execute.\n * @return {function} The wrapped function.\n */\nexport const compose = (...callbacks) =>\n    (arg) =>\n        callbacks.reduceRight(\n            (acc, callback) =>\n                callback(acc),\n            arg,\n        );\n\n/**\n * Create a wrapped version of a function, that will return new functions\n * until the number of total arguments passed reaches the arguments length\n * of the original function (at which point the function will execute).\n * @param {function} callback Callback function to execute.\n * @return {function} The wrapped function.\n */\nexport const curry = (callback) => {\n    const curried = (...args) =>\n        args.length >= callback.length ?\n            callback(...args) :\n            (...newArgs) =>\n                curried(\n                    ...args.concat(newArgs),\n                );\n\n    return curried;\n};\n\n/**\n * Create a wrapped version of a function that executes once per wait period\n * (using the most recent arguments passed to it).\n * @param {function} callback Callback function to execute.\n * @param {number} [wait=0] The number of milliseconds to wait until next execution.\n * @param {Boolean} [leading=false] Whether to execute on the leading edge of the wait period.\n * @param {Boolean} [trailing=true] Whether to execute on the trailing edge of the wait period.\n * @return {function} The wrapped function.\n */\nexport const debounce = (callback, wait = 0, leading = false, trailing = true) => {\n    let debounceReference;\n    let lastRan;\n    let newArgs;\n\n    const debounced = (...args) => {\n        const now = Date.now();\n        const delta = lastRan ?\n            now - lastRan :\n            null;\n\n        if (leading && (delta === null || delta >= wait)) {\n            lastRan = now;\n            callback(...args);\n            return;\n        }\n\n        newArgs = args;\n        if (!trailing) {\n            return;\n        }\n\n        if (debounceReference) {\n            clearTimeout(debounceReference);\n        }\n\n        debounceReference = setTimeout(\n            (_) => {\n                lastRan = Date.now();\n                callback(...newArgs);\n\n                debounceReference = null;\n            },\n            wait,\n        );\n    };\n\n    debounced.cancel = (_) => {\n        if (!debounceReference) {\n            return;\n        }\n\n        clearTimeout(debounceReference);\n\n        debounceReference = null;\n    };\n\n    return debounced;\n};\n\n/**\n * Evaluate a value from a function or value.\n * @param {*} value The value to evaluate.\n * @return {*} The evaluated value.\n */\nexport const evaluate = (value) =>\n    isFunction(value) ?\n        value() :\n        value;\n\n/**\n * Create a wrapped version of a function that will only ever execute once.\n * Subsequent calls to the wrapped function will return the result of the initial call.\n * @param {function} callback Callback function to execute.\n * @return {function} The wrapped function.\n */\nexport const once = (callback) => {\n    let ran;\n    let result;\n\n    return (...args) => {\n        if (ran) {\n            return result;\n        }\n\n        ran = true;\n        result = callback(...args);\n        return result;\n    };\n};\n\n/**\n * Create a wrapped version of a function with predefined arguments.\n * @param {function} callback Callback function to execute.\n * @param {...*} [defaultArgs] Default arguments to pass to the function.\n * @return {function} The wrapped function.\n */\nexport const partial = (callback, ...defaultArgs) =>\n    (...args) =>\n        callback(\n            ...(defaultArgs\n                .slice()\n                .map((v) =>\n                    isUndefined(v) ?\n                        args.shift() :\n                        v,\n                ).concat(args)\n            ),\n        );\n\n/**\n * Create a wrapped function that will execute each callback in order,\n * passing the result from each function to the next.\n * @param {...function} callbacks Callback functions to execute.\n * @return {function} The wrapped function.\n */\nexport const pipe = (...callbacks) =>\n    (arg) =>\n        callbacks.reduce(\n            (acc, callback) =>\n                callback(acc),\n            arg,\n        );\n\n/**\n * Create a wrapped version of a function that executes at most once per wait period.\n * (using the most recent arguments passed to it).\n * @param {function} callback Callback function to execute.\n * @param {number} [wait=0] The number of milliseconds to wait until next execution.\n * @param {Boolean} [leading=true] Whether to execute on the leading edge of the wait period.\n * @param {Boolean} [trailing=true] Whether to execute on the trailing edge of the wait period.\n * @return {function} The wrapped function.\n */\nexport const throttle = (callback, wait = 0, leading = true, trailing = true) => {\n    let throttleReference;\n    let lastRan;\n    let newArgs;\n    let running;\n\n    const throttled = (...args) => {\n        const now = Date.now();\n        const delta = lastRan ?\n            now - lastRan :\n            null;\n\n        if (leading && (delta === null || delta >= wait)) {\n            lastRan = now;\n            callback(...args);\n            return;\n        }\n\n        newArgs = args;\n        if (running || !trailing) {\n            return;\n        }\n\n        running = true;\n        throttleReference = setTimeout(\n            (_) => {\n                lastRan = Date.now();\n                callback(...newArgs);\n\n                running = false;\n                throttleReference = null;\n            },\n            delta === null ?\n                wait :\n                wait - delta,\n        );\n    };\n\n    throttled.cancel = (_) => {\n        if (!throttleReference) {\n            return;\n        }\n\n        clearTimeout(throttleReference);\n\n        running = false;\n        throttleReference = null;\n    };\n\n    return throttled;\n};\n\n/**\n * Execute a function a specified number of times.\n * @param {function} callback Callback function to execute.\n * @param {number} amount The amount of times to execute the callback.\n */\nexport const times = (callback, amount) => {\n    while (amount--) {\n        if (callback() === false) {\n            break;\n        }\n    }\n};\n","import { isArray, isObject, isPlainObject } from './testing.js';\n\n/**\n * Object methods\n */\n\n/**\n * Merge the values from one or more objects onto an object (recursively).\n * @param {object} object The input object.\n * @param {...object} objects The objects to merge.\n * @return {object} The output objects.\n */\nexport const extend = (object, ...objects) =>\n    objects.reduce(\n        (acc, val) => {\n            for (const k in val) {\n                if (isArray(val[k])) {\n                    acc[k] = extend(\n                        isArray(acc[k]) ?\n                            acc[k] :\n                            [],\n                        val[k],\n                    );\n                } else if (isPlainObject(val[k])) {\n                    acc[k] = extend(\n                        isPlainObject(acc[k]) ?\n                            acc[k] :\n                            {},\n                        val[k],\n                    );\n                } else {\n                    acc[k] = val[k];\n                }\n            }\n            return acc;\n        },\n        object,\n    );\n\n/**\n * Remove a specified key from an object using dot notation.\n * @param {object} object The input object.\n * @param {string} key The key to remove from the object.\n */\nexport const forgetDot = (object, key) => {\n    const keys = key.split('.');\n    while ((key = keys.shift())) {\n        if (\n            !isObject(object) ||\n            !(key in object)\n        ) {\n            break;\n        }\n\n        if (keys.length) {\n            object = object[key];\n        } else {\n            delete object[key];\n        }\n    }\n};\n\n/**\n * Retrieve the value of a specified key from an object using dot notation.\n * @param {object} object The input object.\n * @param {string} key The key to retrieve from the object.\n * @param {*} [defaultValue] The default value if key does not exist.\n * @return {*} The value retrieved from the object.\n */\nexport const getDot = (object, key, defaultValue) => {\n    const keys = key.split('.');\n    while ((key = keys.shift())) {\n        if (\n            !isObject(object) ||\n            !(key in object)\n        ) {\n            return defaultValue;\n        }\n\n        object = object[key];\n    }\n\n    return object;\n};\n\n/**\n * Returns true if a specified key exists in an object using dot notation.\n * @param {object} object The input object.\n * @param {string} key The key to test for in the object.\n * @return {Boolean} TRUE if the key exists, otherwise FALSE.\n */\nexport const hasDot = (object, key) => {\n    const keys = key.split('.');\n    while ((key = keys.shift())) {\n        if (\n            !isObject(object) ||\n            !(key in object)\n        ) {\n            return false;\n        }\n\n        object = object[key];\n    }\n\n    return true;\n};\n\n/**\n * Retrieve values of a specified key from an array of objects using dot notation.\n * @param {object[]} objects The input objects.\n * @param {string} key The key to retrieve from the objects.\n * @param {*} [defaultValue] The default value if key does not exist.\n * @return {array} An array of values retrieved from the objects.\n */\nexport const pluckDot = (objects, key, defaultValue) =>\n    objects\n        .map((pointer) =>\n            getDot(pointer, key, defaultValue),\n        );\n\n/**\n * Set a specified value of a key for an object using dot notation.\n * @param {object} object The input object.\n * @param {string} key The key to set in the object.\n * @param {*} value The value to set.\n * @param {Boolean} [overwrite=true] Whether to overwrite, if the key already exists.\n */\nexport const setDot = (object, key, value, overwrite = true) => {\n    const keys = key.split('.');\n    while ((key = keys.shift())) {\n        if (key === '*') {\n            for (const k in object) {\n                if (!{}.hasOwnProperty.call(object, k)) {\n                    continue;\n                }\n\n                setDot(\n                    object,\n                    [k].concat(keys).join('.'),\n                    value,\n                    overwrite,\n                );\n            }\n            return;\n        }\n\n        if (keys.length) {\n            if (\n                !isObject(object[key]) ||\n                !(key in object)\n            ) {\n                object[key] = {};\n            }\n\n            object = object[key];\n        } else if (\n            overwrite ||\n            !(key in object)\n        ) {\n            object[key] = value;\n        }\n    }\n};\n","import { random } from './math.js';\n\n// HTML escape characters\nconst escapeChars = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    '\\'': '&apos;',\n};\n\nconst unescapeChars = {\n    amp: '&',\n    lt: '<',\n    gt: '>',\n    quot: '\"',\n    apos: '\\'',\n};\n\n/**\n * String methods\n */\n\n/**\n * Split a string into individual words.\n * @param {string} string The input string.\n * @return {string[]} The split parts of the string.\n */\nconst _splitString = (string) =>\n    `${string}`\n        .split(/[^a-zA-Z0-9']|(?=[A-Z])/)\n        .reduce(\n            (acc, word) => {\n                word = word.replace(/[^\\w]/, '').toLowerCase();\n                if (word) {\n                    acc.push(word);\n                }\n                return acc;\n            },\n            [],\n        );\n\n/**\n * Convert a string to camelCase.\n * @param {string} string The input string.\n * @return {string} The camelCased string.\n */\nexport const camelCase = (string) =>\n    _splitString(string)\n        .map(\n            (word, index) =>\n                index ?\n                    capitalize(word) :\n                    word,\n        )\n        .join('');\n\n/**\n * Convert the first character of string to upper case and the remaining to lower case.\n * @param {string} string The input string.\n * @return {string} The capitalized string.\n */\nexport const capitalize = (string) =>\n    string.charAt(0).toUpperCase() +\n    string.substring(1).toLowerCase();\n\n/**\n * Convert HTML special characters in a string to their corresponding HTML entities.\n * @param {string} string The input string.\n * @return {string} The escaped string.\n */\nexport const escape = (string) =>\n    string.replace(\n        /[&<>\"']/g,\n        (match) =>\n            escapeChars[match],\n    );\n\n/**\n * Escape RegExp special characters in a string.\n * @param {string} string The input string.\n * @return {string} The escaped string.\n */\nexport const escapeRegExp = (string) =>\n    string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\n/**\n * Convert a string to a humanized form.\n * @param {string} string The input string.\n * @return {string} The humanized string.\n */\nexport const humanize = (string) =>\n    capitalize(\n        _splitString(string)\n            .join(' '),\n    );\n\n/**\n * Convert a string to kebab-case.\n * @param {string} string The input string.\n * @return {string} The kebab-cased string.\n */\nexport const kebabCase = (string) =>\n    _splitString(string)\n        .join('-')\n        .toLowerCase();\n\n/**\n * Convert a string to PascalCase.\n * @param {string} string The input string.\n * @return {string} The camelCased string.\n */\nexport const pascalCase = (string) =>\n    _splitString(string)\n        .map(\n            (word) =>\n                word.charAt(0).toUpperCase() +\n                word.substring(1),\n        )\n        .join('');\n\n/**\n * Return a random string.\n * @param {number} [length=16] The length of the output string.\n * @param {string} [chars=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWYXZ0123456789] The characters to generate the string from.\n * @return {string} The random string.\n */\nexport const randomString = (length = 16, chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWYXZ0123456789') =>\n    new Array(length)\n        .fill()\n        .map(\n            (_) =>\n                chars[random(chars.length) | 0],\n        )\n        .join('');\n\n/**\n * Convert a string to snake_case.\n * @param {string} string The input string.\n * @return {string} The snake_cased string.\n */\nexport const snakeCase = (string) =>\n    _splitString(string)\n        .join('_')\n        .toLowerCase();\n\n/**\n * Convert HTML entities in a string to their corresponding characters.\n * @param {string} string The input string.\n * @return {string} The unescaped string.\n */\nexport const unescape = (string) =>\n    string.replace(\n        /&(amp|lt|gt|quot|apos);/g,\n        (_, code) =>\n            unescapeChars[code],\n    );\n"],"names":[],"mappings":"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"}