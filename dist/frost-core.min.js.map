{"version":3,"names":["isArray","Array","isArrayLike","value","isObject","isFunction","isWindow","isElement","Symbol","iterator","isNumeric","length","nodeType","isNaN","Number","isNull","parseFloat","isFinite","Object","isPlainObject","constructor","isUndefined","undefined","document","defaultView","clamp","min","max","Math","len","hypot","map","fromMin","fromMax","toMin","toMax","random","a","b","randomInt","toStep","step","round","toFixed","replace","merge","array","arrays","reduce","acc","other","prototype","push","apply","unique","from","Set","isBrowser","window","_requestAnimationFrame","args","requestAnimationFrame","callback","setTimeout","extend","object","objects","val","k","getDot","key","defaultValue","keys","split","shift","setDot","overwrite","hasOwnProperty","call","concat","join","escapeChars","unescapeChars","amp","lt","gt","quot","apos","_splitString","string","word","toLowerCase","capitalize","charAt","toUpperCase","substring","leading","animationReference","newArgs","running","animation","_","cancel","global","cancelAnimationFrame","clearTimeout","index","callbacks","arg","reduceRight","curried","wait","trailing","debounceReference","lastRan","debounced","now","Date","delta","filter","some","includes","x1","y1","x2","y2","match","every","otherIndex","v1","v2","host","amount","ran","result","defaultArgs","slice","v","pointer","chars","fill","start","end","sign","abs","i","throttleReference","throttled","code"],"sources":["../src/testing.js","../src/math.js","../src/array.js","../src/function.js","../src/object.js","../src/string.js"],"sourcesContent":["/**\n * Testing methods\n */\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\nconst DOCUMENT_NODE = 9;\nconst DOCUMENT_FRAGMENT_NODE = 11;\n\n/**\n * Returns true if the value is an array.\n * @param {*} value The value to test.\n * @returns {Boolean} TRUE if the value is an array, otherwise FALSE.\n */\nexport const isArray = Array.isArray;\n\n/**\n * Returns true if the value is array-like.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is array-like, otherwise FALSE.\n */\nexport const isArrayLike = (value) =>\n    isArray(value) ||\n    (\n        isObject(value) &&\n        !isFunction(value) &&\n        !isWindow(value) &&\n        !isElement(value) &&\n        (\n            (\n                Symbol.iterator in value &&\n                isFunction(value[Symbol.iterator])\n            ) ||\n            (\n                'length' in value &&\n                isNumeric(value.length) &&\n                (\n                    !value.length ||\n                    value.length - 1 in value\n                )\n            )\n        )\n    );\n\n/**\n * Returns true if the value is a Boolean.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is boolean, otherwise FALSE.\n */\nexport const isBoolean = (value) =>\n    value === !!value;\n\n/**\n * Returns true if the value is a Document.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is a Document, otherwise FALSE.\n */\nexport const isDocument = (value) =>\n    !!value &&\n    value.nodeType === DOCUMENT_NODE;\n\n/**\n * Returns true if the value is a HTMLElement.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is a HTMLElement, otherwise FALSE.\n */\nexport const isElement = (value) =>\n    !!value &&\n    value.nodeType === ELEMENT_NODE;\n\n/**\n * Returns true if the value is a DocumentFragment.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is a DocumentFragment, otherwise FALSE.\n */\nexport const isFragment = (value) =>\n    !!value &&\n    value.nodeType === DOCUMENT_FRAGMENT_NODE &&\n    !value.host;\n\n/**\n * Returns true if the value is a function.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is a function, otherwise FALSE.\n */\nexport const isFunction = (value) =>\n    typeof value === 'function';\n\n/**\n * Returns true if the value is NaN.\n * @param {*} value The value to test.\n * @returns {Boolean} TRUE if the value is NaN, otherwise FALSE.\n */\nexport const isNaN = Number.isNaN;\n\n/**\n * Returns true if the value is a Node.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is a Node, otherwise FALSE.\n */\nexport const isNode = (value) =>\n    !!value &&\n    (\n        value.nodeType === ELEMENT_NODE ||\n        value.nodeType === TEXT_NODE ||\n        value.nodeType === COMMENT_NODE\n    );\n\n/**\n * Returns true if the value is null.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is null, otherwise FALSE.\n */\nexport const isNull = (value) =>\n    value === null;\n\n/**\n * Returns true if the value is numeric.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is numeric, otherwise FALSE.\n */\nexport const isNumeric = (value) =>\n    !isNaN(parseFloat(value)) &&\n    isFinite(value);\n\n/**\n * Returns true if the value is an object.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is an object, otherwise FALSE.\n */\nexport const isObject = (value) =>\n    !!value &&\n    value === Object(value);\n\n/**\n * Returns true if the value is a plain object.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is a plain object, otherwise FALSE.\n */\nexport const isPlainObject = (value) =>\n    !!value &&\n    value.constructor === Object;\n\n/**\n * Returns true if the value is a ShadowRoot.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is a ShadowRoot, otherwise FALSE.\n */\nexport const isShadow = (value) =>\n    !!value &&\n    value.nodeType === DOCUMENT_FRAGMENT_NODE &&\n    !!value.host;\n\n/**\n * Returns true if the value is a string.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE is the value is a string, otherwise FALSE.\n */\nexport const isString = (value) =>\n    value === `${value}`;\n\n/**\n * Returns true if the value is a text Node.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is a text Node, otherwise FALSE.\n */\nexport const isText = (value) =>\n    !!value &&\n    value.nodeType === TEXT_NODE;\n\n/**\n * Returns true if the value is undefined.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE if the value is undefined, otherwise FALSE.\n */\nexport const isUndefined = (value) =>\n    value === undefined;\n\n/**\n * Returns true if the value is a Window.\n * @param {*} value The value to test.\n * @return {Boolean} TRUE is the value is a Window, otherwise FALSE.\n */\nexport const isWindow = (value) =>\n    !!value &&\n    !!value.document &&\n    value.document.defaultView === value;\n","import { isNull } from './testing.js';\n\n/**\n * Math methods\n */\n\n/**\n * Clamp a value between a min and max.\n * @param {number} value The value to clamp.\n * @param {number} [min=0] The minimum value of the clamped range.\n * @param {number} [max=1] The maximum value of the clamped range.\n * @return {number} The clamped value.\n */\nexport const clamp = (value, min = 0, max = 1) =>\n    Math.max(\n        min,\n        Math.min(\n            max,\n            value,\n        ),\n    );\n\n/**\n * Clamp a value between 0 and 100.\n * @param {number} value The value to clamp.\n * @return {number} The clamped value.\n */\nexport const clampPercent = (value) =>\n    clamp(value, 0, 100);\n\n/**\n * Get the distance between two vectors.\n * @param {number} x1 The first vector X co-ordinate.\n * @param {number} y1 The first vector Y co-ordinate.\n * @param {number} x2 The second vector X co-ordinate.\n * @param {number} y2 The second vector Y co-ordinate.\n * @return {number} The distance between the vectors.\n */\nexport const dist = (x1, y1, x2, y2) =>\n    len(\n        x1 - x2,\n        y1 - y2,\n    );\n\n/**\n * Inverse linear interpolation from one value to another.\n * @param {number} v1 The starting value.\n * @param {number} v2 The ending value.\n * @param {number} value The value to inverse interpolate.\n * @return {number} The interpolated amount.\n */\nexport const inverseLerp = (v1, v2, value) =>\n    (value - v1) / (v2 - v1);\n\n/**\n * Get the length of an X,Y vector.\n * @param {number} x The X co-ordinate.\n * @param {number} y The Y co-ordinate.\n * @returns {number} The length of the vector.\n */\nexport const len = Math.hypot;\n\n/**\n * Linear interpolation from one value to another.\n * @param {number} v1 The starting value.\n * @param {number} v2 The ending value.\n * @param {number} amount The amount to interpolate.\n * @return {number} The interpolated value.\n */\nexport const lerp = (v1, v2, amount) =>\n    v1 *\n    (1 - amount) +\n    v2 *\n    amount;\n\n/**\n * Map a value from one range to another.\n * @param {number} value The value to map.\n * @param {number} fromMin The minimum value of the current range.\n * @param {number} fromMax The maximum value of the current range.\n * @param {number} toMin The minimum value of the target range.\n * @param {number} toMax The maximum value of the target range.\n * @return {number} The mapped value.\n */\nexport const map = (value, fromMin, fromMax, toMin, toMax) =>\n    (value - fromMin) *\n    (toMax - toMin) /\n    (fromMax - fromMin) +\n    toMin;\n\n/**\n * Return a random floating-point number.\n * @param {number} [a=1] The minimum value (inclusive).\n * @param {number} [b] The maximum value (exclusive).\n * @return {number} A random number.\n */\nexport const random = (a = 1, b = null) =>\n    isNull(b) ?\n        Math.random() * a :\n        map(\n            Math.random(),\n            0,\n            1,\n            a,\n            b,\n        );\n\n/**\n * Return a random number.\n * @param {number} [a=1] The minimum value (inclusive).\n * @param {number} [b] The maximum value (exclusive).\n * @return {number} A random number.\n */\nexport const randomInt = (a = 1, b = null) =>\n    random(a, b) | 0;\n\n/**\n * Constrain a number to a specified step-size.\n * @param {number} value The value to constrain.\n * @param {number} step The minimum step-size.\n * @return {number} The constrained value.\n */\nexport const toStep = (value, step = 0.01) =>\n    parseFloat(\n        (\n            Math.round(value / step) *\n            step\n        ).toFixed(\n            `${step}`.replace(/\\d*\\.?/, '').length,\n        ),\n    );\n","import { randomInt, toStep } from './math.js';\nimport { isArray, isArrayLike, isUndefined } from './testing.js';\n\n/**\n * Array methods\n */\n\n/**\n * Create a new array containing the values of the first array, that do not exist in any of the additional passed arrays.\n * @param {array} array The input array.\n * @param {...array} arrays The arrays to compare against.\n * @return {array} The output array.\n */\nexport const diff = (array, ...arrays) => {\n    arrays = arrays.map(unique);\n    return array.filter(\n        (value) => !arrays\n            .some((other) => other.includes(value)),\n    );\n};\n\n/**\n * Create a new array containing the unique values that exist in all of the passed arrays.\n * @param {...array} arrays The input arrays.\n * @return {array} The output array.\n */\nexport const intersect = (...arrays) =>\n    unique(\n        arrays\n            .reduce(\n                (acc, array, index) => {\n                    array = unique(array);\n                    return merge(\n                        acc,\n                        array.filter(\n                            (value) =>\n                                arrays.every(\n                                    (other, otherIndex) =>\n                                        index == otherIndex ||\n                                        other.includes(value),\n                                ),\n                        ),\n                    );\n                },\n                [],\n            ),\n    );\n\n/**\n * Merge the values from one or more arrays or array-like objects onto an array.\n * @param {array} array The input array.\n * @param {...array|object} arrays The arrays or array-like objects to merge.\n * @return {array} The output array.\n */\nexport const merge = (array = [], ...arrays) =>\n    arrays.reduce(\n        (acc, other) => {\n            Array.prototype.push.apply(acc, other);\n            return array;\n        },\n        array,\n    );\n\n/**\n * Return a random value from an array.\n * @param {array} array The input array.\n * @return {*} A random value from the array, or null if it is empty.\n */\nexport const randomValue = (array) =>\n    array.length ?\n        array[randomInt(array.length)] :\n        null;\n\n/**\n * Return an array containing a range of values.\n * @param {number} start The first value of the sequence.\n * @param {number} end The value to end the sequence on.\n * @param {number} [step=1] The increment between values in the sequence.\n * @return {number[]} The array of values from start to end.\n */\nexport const range = (start, end, step = 1) => {\n    const sign = Math.sign(end - start);\n    return new Array(\n        (\n            (\n                Math.abs(end - start) /\n                step\n            ) +\n            1\n        ) | 0,\n    )\n        .fill()\n        .map(\n            (_, i) =>\n                start + toStep(\n                    (i * step * sign),\n                    step,\n                ),\n        );\n};\n\n/**\n * Remove duplicate elements in an array.\n * @param {array} array The input array.\n * @return {array} The filtered array.\n */\nexport const unique = (array) =>\n    Array.from(\n        new Set(array),\n    );\n\n/**\n * Create an array from any value.\n * @param {*} value The input value.\n * @return {array} The wrapped array.\n */\nexport const wrap = (value) =>\n    isUndefined(value) ?\n        [] :\n        (\n            isArray(value) ?\n                value :\n                (\n                    isArrayLike(value) ?\n                        merge([], value) :\n                        [value]\n                )\n        );\n","import { isFunction, isUndefined } from './testing.js';\n\n/**\n * Function methods\n */\n\nconst isBrowser = typeof window !== 'undefined' && 'requestAnimationFrame' in window;\n\n/**\n * Execute a callback on the next animation frame\n * @param {function} callback Callback function to execute.\n * @return {number} The request ID.\n */\nconst _requestAnimationFrame = isBrowser ?\n    (...args) => window.requestAnimationFrame(...args) :\n    (callback) => setTimeout(callback, 1000 / 60);\n\n/**\n * Create a wrapped version of a function that executes at most once per animation frame\n * (using the most recent arguments passed to it).\n * @param {function} callback Callback function to execute.\n * @param {Boolean} [leading] Whether to execute on the leading edge of the animation frame.\n * @return {function} The wrapped function.\n */\nexport const animation = (callback, leading) => {\n    let animationReference;\n    let newArgs;\n    let running;\n\n    const animation = (...args) => {\n        newArgs = args;\n\n        if (running) {\n            return;\n        }\n\n        if (leading) {\n            callback(...newArgs);\n        }\n\n        running = true;\n        animationReference = _requestAnimationFrame((_) => {\n            if (!leading) {\n                callback(...newArgs);\n            }\n\n            running = false;\n            animationReference = null;\n        });\n    };\n\n    animation.cancel = (_) => {\n        if (!animationReference) {\n            return;\n        }\n\n        if (isBrowser) {\n            global.cancelAnimationFrame(animationReference);\n        } else {\n            clearTimeout(animationReference);\n        }\n\n        running = false;\n        animationReference = null;\n    };\n\n    return animation;\n};\n\n/**\n * Create a wrapped function that will execute each callback in reverse order,\n * passing the result from each function to the previous.\n * @param {...function} callbacks Callback functions to execute.\n * @return {function} The wrapped function.\n */\nexport const compose = (...callbacks) =>\n    (arg) =>\n        callbacks.reduceRight(\n            (acc, callback) =>\n                callback(acc),\n            arg,\n        );\n\n/**\n * Create a wrapped version of a function, that will return new functions\n * until the number of total arguments passed reaches the arguments length\n * of the original function (at which point the function will execute).\n * @param {function} callback Callback function to execute.\n * @return {function} The wrapped function.\n */\nexport const curry = (callback) => {\n    const curried = (...args) =>\n        args.length >= callback.length ?\n            callback(...args) :\n            (...newArgs) =>\n                curried(\n                    ...args.concat(newArgs),\n                );\n\n    return curried;\n};\n\n/**\n * Create a wrapped version of a function that executes once per wait period\n * (using the most recent arguments passed to it).\n * @param {function} callback Callback function to execute.\n * @param {number} [wait=0] The number of milliseconds to wait until next execution.\n * @param {Boolean} [leading=false] Whether to execute on the leading edge of the wait period.\n * @param {Boolean} [trailing=true] Whether to execute on the trailing edge of the wait period.\n * @return {function} The wrapped function.\n */\nexport const debounce = (callback, wait = 0, leading = false, trailing = true) => {\n    let debounceReference;\n    let lastRan;\n    let newArgs;\n\n    const debounced = (...args) => {\n        const now = Date.now();\n        const delta = lastRan ?\n            now - lastRan :\n            null;\n\n        if (leading && (delta === null || delta >= wait)) {\n            lastRan = now;\n            callback(...args);\n            return;\n        }\n\n        newArgs = args;\n        if (!trailing) {\n            return;\n        }\n\n        if (debounceReference) {\n            clearTimeout(debounceReference);\n        }\n\n        debounceReference = setTimeout(\n            (_) => {\n                lastRan = Date.now();\n                callback(...newArgs);\n\n                debounceReference = null;\n            },\n            wait,\n        );\n    };\n\n    debounced.cancel = (_) => {\n        if (!debounceReference) {\n            return;\n        }\n\n        clearTimeout(debounceReference);\n\n        debounceReference = null;\n    };\n\n    return debounced;\n};\n\n/**\n * Evaluate a value from a function or value.\n * @param {*} value The value to evaluate.\n * @return {*} The evaluated value.\n */\nexport const evaluate = (value) =>\n    isFunction(value) ?\n        value() :\n        value;\n\n/**\n * Create a wrapped version of a function that will only ever execute once.\n * Subsequent calls to the wrapped function will return the result of the initial call.\n * @param {function} callback Callback function to execute.\n * @return {function} The wrapped function.\n */\nexport const once = (callback) => {\n    let ran;\n    let result;\n\n    return (...args) => {\n        if (ran) {\n            return result;\n        }\n\n        ran = true;\n        result = callback(...args);\n        return result;\n    };\n};\n\n/**\n * Create a wrapped version of a function with predefined arguments.\n * @param {function} callback Callback function to execute.\n * @param {...*} [defaultArgs] Default arguments to pass to the function.\n * @return {function} The wrapped function.\n */\nexport const partial = (callback, ...defaultArgs) =>\n    (...args) =>\n        callback(\n            ...(defaultArgs\n                .slice()\n                .map((v) =>\n                    isUndefined(v) ?\n                        args.shift() :\n                        v,\n                ).concat(args)\n            ),\n        );\n\n/**\n * Create a wrapped function that will execute each callback in order,\n * passing the result from each function to the next.\n * @param {...function} callbacks Callback functions to execute.\n * @return {function} The wrapped function.\n */\nexport const pipe = (...callbacks) =>\n    (arg) =>\n        callbacks.reduce(\n            (acc, callback) =>\n                callback(acc),\n            arg,\n        );\n\n/**\n * Create a wrapped version of a function that executes at most once per wait period.\n * (using the most recent arguments passed to it).\n * @param {function} callback Callback function to execute.\n * @param {number} [wait=0] The number of milliseconds to wait until next execution.\n * @param {Boolean} [leading=true] Whether to execute on the leading edge of the wait period.\n * @param {Boolean} [trailing=true] Whether to execute on the trailing edge of the wait period.\n * @return {function} The wrapped function.\n */\nexport const throttle = (callback, wait = 0, leading = true, trailing = true) => {\n    let throttleReference;\n    let lastRan;\n    let newArgs;\n    let running;\n\n    const throttled = (...args) => {\n        const now = Date.now();\n        const delta = lastRan ?\n            now - lastRan :\n            null;\n\n        if (leading && (delta === null || delta >= wait)) {\n            lastRan = now;\n            callback(...args);\n            return;\n        }\n\n        newArgs = args;\n        if (running || !trailing) {\n            return;\n        }\n\n        running = true;\n        throttleReference = setTimeout(\n            (_) => {\n                lastRan = Date.now();\n                callback(...newArgs);\n\n                running = false;\n                throttleReference = null;\n            },\n            delta === null ?\n                wait :\n                wait - delta,\n        );\n    };\n\n    throttled.cancel = (_) => {\n        if (!throttleReference) {\n            return;\n        }\n\n        clearTimeout(throttleReference);\n\n        running = false;\n        throttleReference = null;\n    };\n\n    return throttled;\n};\n\n/**\n * Execute a function a specified number of times.\n * @param {function} callback Callback function to execute.\n * @param {number} amount The amount of times to execute the callback.\n */\nexport const times = (callback, amount) => {\n    while (amount--) {\n        if (callback() === false) {\n            break;\n        }\n    }\n};\n","import { isArray, isObject, isPlainObject } from './testing.js';\n\n/**\n * Object methods\n */\n\n/**\n * Merge the values from one or more objects onto an object (recursively).\n * @param {object} object The input object.\n * @param {...object} objects The objects to merge.\n * @return {object} The output objects.\n */\nexport const extend = (object, ...objects) =>\n    objects.reduce(\n        (acc, val) => {\n            for (const k in val) {\n                if (isArray(val[k])) {\n                    acc[k] = extend(\n                        isArray(acc[k]) ?\n                            acc[k] :\n                            [],\n                        val[k],\n                    );\n                } else if (isPlainObject(val[k])) {\n                    acc[k] = extend(\n                        isPlainObject(acc[k]) ?\n                            acc[k] :\n                            {},\n                        val[k],\n                    );\n                } else {\n                    acc[k] = val[k];\n                }\n            }\n            return acc;\n        },\n        object,\n    );\n\n/**\n * Remove a specified key from an object using dot notation.\n * @param {object} object The input object.\n * @param {string} key The key to remove from the object.\n */\nexport const forgetDot = (object, key) => {\n    const keys = key.split('.');\n    while ((key = keys.shift())) {\n        if (\n            !isObject(object) ||\n            !(key in object)\n        ) {\n            break;\n        }\n\n        if (keys.length) {\n            object = object[key];\n        } else {\n            delete object[key];\n        }\n    }\n};\n\n/**\n * Retrieve the value of a specified key from an object using dot notation.\n * @param {object} object The input object.\n * @param {string} key The key to retrieve from the object.\n * @param {*} [defaultValue] The default value if key does not exist.\n * @return {*} The value retrieved from the object.\n */\nexport const getDot = (object, key, defaultValue) => {\n    const keys = key.split('.');\n    while ((key = keys.shift())) {\n        if (\n            !isObject(object) ||\n            !(key in object)\n        ) {\n            return defaultValue;\n        }\n\n        object = object[key];\n    }\n\n    return object;\n};\n\n/**\n * Returns true if a specified key exists in an object using dot notation.\n * @param {object} object The input object.\n * @param {string} key The key to test for in the object.\n * @return {Boolean} TRUE if the key exists, otherwise FALSE.\n */\nexport const hasDot = (object, key) => {\n    const keys = key.split('.');\n    while ((key = keys.shift())) {\n        if (\n            !isObject(object) ||\n            !(key in object)\n        ) {\n            return false;\n        }\n\n        object = object[key];\n    }\n\n    return true;\n};\n\n/**\n * Retrieve values of a specified key from an array of objects using dot notation.\n * @param {object[]} objects The input objects.\n * @param {string} key The key to retrieve from the objects.\n * @param {*} [defaultValue] The default value if key does not exist.\n * @return {array} An array of values retrieved from the objects.\n */\nexport const pluckDot = (objects, key, defaultValue) =>\n    objects\n        .map((pointer) =>\n            getDot(pointer, key, defaultValue),\n        );\n\n/**\n * Set a specified value of a key for an object using dot notation.\n * @param {object} object The input object.\n * @param {string} key The key to set in the object.\n * @param {*} value The value to set.\n * @param {Boolean} [overwrite=true] Whether to overwrite, if the key already exists.\n */\nexport const setDot = (object, key, value, overwrite = true) => {\n    const keys = key.split('.');\n    while ((key = keys.shift())) {\n        if (key === '*') {\n            for (const k in object) {\n                if (!{}.hasOwnProperty.call(object, k)) {\n                    continue;\n                }\n\n                setDot(\n                    object,\n                    [k].concat(keys).join('.'),\n                    value,\n                    overwrite,\n                );\n            }\n            return;\n        }\n\n        if (keys.length) {\n            if (\n                !isObject(object[key]) ||\n                !(key in object)\n            ) {\n                object[key] = {};\n            }\n\n            object = object[key];\n        } else if (\n            overwrite ||\n            !(key in object)\n        ) {\n            object[key] = value;\n        }\n    }\n};\n","import { random } from './math.js';\n\n// HTML escape characters\nconst escapeChars = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    '\\'': '&apos;',\n};\n\nconst unescapeChars = {\n    amp: '&',\n    lt: '<',\n    gt: '>',\n    quot: '\"',\n    apos: '\\'',\n};\n\n/**\n * String methods\n */\n\n/**\n * Split a string into individual words.\n * @param {string} string The input string.\n * @return {string[]} The split parts of the string.\n */\nconst _splitString = (string) =>\n    `${string}`\n        .split(/[^a-zA-Z0-9']|(?=[A-Z])/)\n        .reduce(\n            (acc, word) => {\n                word = word.replace(/[^\\w]/, '').toLowerCase();\n                if (word) {\n                    acc.push(word);\n                }\n                return acc;\n            },\n            [],\n        );\n\n/**\n * Convert a string to camelCase.\n * @param {string} string The input string.\n * @return {string} The camelCased string.\n */\nexport const camelCase = (string) =>\n    _splitString(string)\n        .map(\n            (word, index) =>\n                index ?\n                    capitalize(word) :\n                    word,\n        )\n        .join('');\n\n/**\n * Convert the first character of string to upper case and the remaining to lower case.\n * @param {string} string The input string.\n * @return {string} The capitalized string.\n */\nexport const capitalize = (string) =>\n    string.charAt(0).toUpperCase() +\n    string.substring(1).toLowerCase();\n\n/**\n * Convert HTML special characters in a string to their corresponding HTML entities.\n * @param {string} string The input string.\n * @return {string} The escaped string.\n */\nexport const escape = (string) =>\n    string.replace(\n        /[&<>\"']/g,\n        (match) =>\n            escapeChars[match],\n    );\n\n/**\n * Escape RegExp special characters in a string.\n * @param {string} string The input string.\n * @return {string} The escaped string.\n */\nexport const escapeRegExp = (string) =>\n    string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\n/**\n * Convert a string to a humanized form.\n * @param {string} string The input string.\n * @return {string} The humanized string.\n */\nexport const humanize = (string) =>\n    capitalize(\n        _splitString(string)\n            .join(' '),\n    );\n\n/**\n * Convert a string to kebab-case.\n * @param {string} string The input string.\n * @return {string} The kebab-cased string.\n */\nexport const kebabCase = (string) =>\n    _splitString(string)\n        .join('-')\n        .toLowerCase();\n\n/**\n * Convert a string to PascalCase.\n * @param {string} string The input string.\n * @return {string} The camelCased string.\n */\nexport const pascalCase = (string) =>\n    _splitString(string)\n        .map(\n            (word) =>\n                word.charAt(0).toUpperCase() +\n                word.substring(1),\n        )\n        .join('');\n\n/**\n * Return a random string.\n * @param {number} [length=16] The length of the output string.\n * @param {string} [chars=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWYXZ0123456789] The characters to generate the string from.\n * @return {string} The random string.\n */\nexport const randomString = (length = 16, chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWYXZ0123456789') =>\n    new Array(length)\n        .fill()\n        .map(\n            (_) =>\n                chars[random(chars.length) | 0],\n        )\n        .join('');\n\n/**\n * Convert a string to snake_case.\n * @param {string} string The input string.\n * @return {string} The snake_cased string.\n */\nexport const snakeCase = (string) =>\n    _splitString(string)\n        .join('_')\n        .toLowerCase();\n\n/**\n * Convert HTML entities in a string to their corresponding characters.\n * @param {string} string The input string.\n * @return {string} The unescaped string.\n */\nexport const unescape = (string) =>\n    string.replace(\n        /&(amp|lt|gt|quot|apos);/g,\n        (_, code) =>\n            unescapeChars[code],\n    );\n"],"mappings":"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"}